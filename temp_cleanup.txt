            return \"Erro ao executar ferramenta: \" + execution.getError();
        }
        
        String prompt = String.format(
            \"User asked: \\\"%s\\\"\\n\\n\" +
            \"Tool used: %s\\n\" +
            \"Tool result: %s\\n\\n\" +
            \"Create a clear, helpful response in Portuguese based on the tool result.\",
            query, execution.getToolName(), execution.getResult()
        );
        
        return llmService.generateResponse(prompt, null);
    }

    private String generateChainResponse(String query, List<ToolExecution> executions) {
        StringBuilder prompt = new StringBuilder();
        prompt.append(String.format(\"User asked: \\\"%s\\\"\\n\\n\", query));
        prompt.append(\"Tool chain execution results:\\n\");
        
        for (int i = 0; i < executions.size(); i++) {
            ToolExecution exec = executions.get(i);
            prompt.append(String.format(\"Step %d - %s: \", i + 1, exec.getToolName()));
            if (exec.isSuccess()) {
                prompt.append(exec.getResult()).append(\"\\n\");
            } else {
                prompt.append(\"FAILED - \").append(exec.getError()).append(\"\\n\");
                break;
            }
        }
        
        prompt.append(\"\\nCreate a comprehensive response in Portuguese summarizing the results.\");
        
        return llmService.generateResponse(prompt.toString(), null);
    }

    private void initializeAvailableMcpTools() {
        if (mcpServers == null) return;
        
        try {
            availableMcpTools = new ArrayList<>();
            
            for (Map.Entry<String, McpSyncClient> entry : mcpServers.mcpClients.entrySet()) {
                String serverName = entry.getKey();
                McpSyncClient client = entry.getValue();
                ListToolsResult toolsResult = client.listTools();
                List<io.modelcontextprotocol.spec.McpSchema.Tool> serverTools = toolsResult.tools();
                for (io.modelcontextprotocol.spec.McpSchema.Tool mcpTool : serverTools) {
                    String toolName = mcpTool.name();
                    String namespacedToolName = serverName + \"_\" + toolName;
                    FunctionDeclaration geminiFunction = llmService.convertMcpToolToFunction(mcpTool, namespacedToolName);
                    availableMcpTools.add(geminiFunction);
                }
            }
            
            if (debugMode) {
                logger.info(\"[TOOLUSE] Initialized {} tools\", availableMcpTools.size());
            }
            
        } catch (Exception e) {
            logger.error(\"Erro ao inicializar ferramentas MCP\", e);
            availableMcpTools = new ArrayList<>();
        }
    }

    public ToolChain getToolChain() {
        return toolChain;
    }

    @Override
    public String buildSystemPrompt() {
        StringBuilder prompt = new StringBuilder();
        prompt.append(\"ToolUse Inference - LLM-driven intelligent tool selection and execution\\n\");
        prompt.append(\"Available tools: \").append(availableMcpTools != null ? availableMcpTools.size() : 0).append(\"\\n\");
        prompt.append(\"Auto-retry with error correction: enabled (max retries: \").append(MAX_RETRIES).append(\")\\n\");
        if (enableToolChaining) {
            prompt.append(\"Tool chaining: enabled (max length: \").append(maxToolChainLength).append(\")\\n\");
        }
        return prompt.toString();
    }

    @Override
    public void close() {
        // Clear caches
        toolSchemaCache.clear();
        if (availableMcpTools != null) {
            availableMcpTools.clear();
        }
    }
}